import chalk from "chalk";
import fs from 'fs';
import { URL } from 'url';
import path from "path";
import { logger } from "../../util/log.mjs";
import { InterfaceCommand } from "../cli.mjs";
function copyFolderSync(from, to) {
    let files = fs.readdirSync(from);
    if (!fs.existsSync(to)) fs.mkdirSync(to);
    files.forEach(element => {
        if (fs.lstatSync(path.join(from, element)).isFile()) {
            fs.copyFileSync(path.join(from, element), path.join(to, element));
        } else {
             copyFolderSync(path.join(from, element), path.join(to, element));
        }
    });
}
class newCommand extends InterfaceCommand {
    name = 'new';
    desc = 'Create a new boiler project';
    isParameter = false;
    showHelp = true;
    help() {
        console.log(`${chalk.bold.yellow('[boiler '+chalk.bold.rgb(143, 200, 54)('builtin/')+'new]: ')}${chalk.bold.gray('Create a new boiler project.')}
${chalk.bold.underline.red('Usage')}: ${chalk.bold.bgBlack.magenta('boiler new <project_name> <project_style> ')}
${chalk.bold.underline.red('Params')}: 
    ${chalk.bold.green('project_name')}: ${chalk.bold.gray('Sets the name of the project for [boilerconf.json]')}
    ${chalk.bold.green('project_style')}: ${chalk.bold.gray('Sets the style of the project for [boilerconf.json]')}`);
    }
    /** @param {string[]} args */run(args) {
        const __filename = new URL('', import.meta.url).pathname;
        // Will contain trailing slash
        const __dirname = new URL('.', import.meta.url).pathname;
        /**
         * @type {string} project_name
         * @type {string} project_style
         */
        const project_name = args[0], project_style = args[1];
        logger.print('NOTE: This command is more optimal in an empty directory, it may edit some files otherwise.');
        if (args.length < 2) return console.log(chalk.bold.red('[provide 2 arguments]'));
        if (!['mjs', 'es6'].includes(project_style)) return console.log(chalk.bold.red('['+project_style+' is not a valid project style.]\nValid styles: '+ chalk.bold.bgBlack.magenta('mjs, es6'))) 
        if (project_style == 'es6') return logger.print('Sorry,', logger.code('es6'), 'is not availabe for Boiler at the moment.')
        let boilerconf = JSON.stringify({"config": {"name": project_name, "style": project_style}}, null, 4)
        fs.writeFileSync(process.cwd() + '/' + 'boilerconf.json', boilerconf);
        copyFolderSync(path.resolve(path.resolve(__dirname, '..'), '..') + '/source', process.cwd() + '/.boiler');
        fs.copyFileSync(path.resolve(__dirname, '..') + '/cli.mjs', process.cwd() + '/.boiler/types/cli.mjs');
        fs.writeFileSync(process.cwd() + '/' + 'main' + (project_style == 'mjs' ? '.mjs' : '.es6'), `${project_style == 'mjs' ? `import * as Boiler from './.boiler/index.mjs';
import logger from './.boiler/index.mjs';

export class Main extends Boiler.Application {
    /**
     * @desc Method to execute when the application exits
     * @param {Boiler.ApplicationStatus} info Information passed into the method
     * @returns {void} \`unknown\` */ beforeExit(info) {
        logger.warn('The application exited with the code ' + logger.num(info.exitCode) + '.');
     };
    /** 
     * @desc Main method to execute
     * @returns {number} The exit code for the application */ async run() { 
        logger.print('Hello, World!');
        return 0;
    };
}` : `const BoilerApi = module.exports = ({
    Main: class Main extends Boiler.Main {
        /** @param {string[]} args \`command-line\` arguments for the file */ constructor(args) { super(); this.app.args = args; };
        /** @desc Main method to execute */ async run() { /*INSERT CODE HERE*/ };
    }
})`}`);
        fs.writeFileSync(process.cwd() + '/boiler.boil.mjs', `/**
        * Boiler runner
        * This file has been auto-generated for project 'main.mjs or main.es6' by Boiler.
        * Last modification at: ${new Date()}
        * DO NOT EDIT THIS FILE. IT WILL NOT BE USED IF EDITED.
        * (c) Mybutton Corporation, 2022. All rights reserved.
        * Boiler.boil();
        */
        import fs from 'fs';
        export class BoilerBuild {
            /**
             * @param {string} file_name The file to run when building, defaults to \`main.mjs\`
             */
            boil(file_name) { 
                if (!fs.existsSync(process.cwd() + '/out')) fs.mkdirSync(process.cwd() + '/out'); //create 'out'
                if (!fs.existsSync(process.cwd() + '/out/boil')) fs.mkdirSync(process.cwd() + '/out/boil'); //create 'boiler'
                fs.writeFileSync(process.cwd() + '/out/boil/run', 'node ./out/boil/start.mjs $*'); //for linux & mac
                fs.writeFileSync(process.cwd() + '/out/boil/run.cmd', '@node ./out/boil/start.mjs %*'); //for windows
                fs.writeFileSync(process.cwd() + '/out/boil/start.mjs', \`// Auto-generated by Boiler.
// Do not edit. It will cause runtime issues when edited.
let cliArgsF = process.argv.slice(2);
import { fileURLToPath } from "url";
export function setArguments(_arguments = []) { cliArgsF = _arguments; };
export function runNow() {
    import('../../main${(project_style == 'mjs' ? '.mjs' : '.es6')}').then(async app => {
        let BoilerApp = new app.Main();
        BoilerApp.cli.rawArgs = process.argv;
        BoilerApp.cli.args = cliArgsF;
        let startDate = Date.now();
        let appRuntime = await BoilerApp.run();
        BoilerApp.beforeExit({exitCode: appRuntime, totalUptime: Date.now() - startDate, process: process});
        return process.exit(appRuntime);
    });
}; 

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  runNow();
}\`);
            };
        }`);
        logger.print(`project created`);
        logger.print(`Project information:`, JSON.parse(boilerconf));
    }
};

export default new newCommand();